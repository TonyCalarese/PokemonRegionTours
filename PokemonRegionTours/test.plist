<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>name</key>
		<string>Null Island</string>
		<key>desc</key>
		<string>Where poorly designed apps go to die</string>
		<key>image</key>
		<string></string>
		<key>lat</key>
		<integer>0</integer>
		<key>long</key>
		<integer>0</integer>
	</dict>
	<dict>
		<key>name</key>
		<string>City Market</string>
		<key>desc</key>
		<string>Ummm idk some long data that I can put in here Codable types can declare a special nested enumeration named CodingKeys that conforms to the CodingKey protocol. When this enumeration is present, its cases serve as the authoritative list of properties that must be included when instances of a codable type are encoded or decoded. The names of the enumeration cases should match the names you&apos;ve given to the corresponding properties in your type.

Omit properties from the CodingKeys enumeration if they won&apos;t be present when decoding instances, or if certain properties shouldn&apos;t be included in an encoded representation. A property omitted from CodingKeys needs a default value in order for its containing type to receive automatic conformance to Decodable or Codable.

If the keys used in your serialized data format don&apos;t match the property names from your data type, provide alternative keys by specifying String as the raw-value type for the CodingKeys enumeration. The string you use as a raw value for each enumeration case is the key name used during encoding and decoding. The association between the case name and its raw value lets you name your data structures according to the Swift API Design Guidelines rather than having to match the names, punctuation, and capitalization of the serialization format you&apos;re modeling.</string>
		<key>image</key>
		<string></string>
		<key>lat</key>
		<real>44.4781004</real>
		<key>long</key>
		<real>-73.2106259</real>
	</dict>
</array>
</plist>
